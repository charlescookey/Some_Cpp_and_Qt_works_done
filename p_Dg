#include <iostream>
#include <string>
#include <map>
#include <set>
#include <vector>
#include <stack>
#include <sstream>

using std::cout;
using std::set;
using std::vector;
using std::string;
using std::map;
using std::stack;

vector<string> findOrder(vector<string>& entry, vector<string> files) {
	map<string, string>FileDependencies{};


	for (int i = 0; i < entry.size(); i += 4) {
		string task = entry[i].substr(6);

		string temp{};
		std::stringstream filesStream(entry[i + 1]);
		filesStream >> temp;


		while (filesStream >> temp) {
			FileDependencies[temp] = task;
			//FileDependencies[temp].insert(task);
		}
	}

	vector<string> ans;

	for (string a : files) {
		if (FileDependencies.count(a) > 0) {
			ans.push_back(FileDependencies[a]);
		}
	}
	return ans;
}



int main() {
	vector<string> taskDefinitionsInput = {
			"task: taskA",
			"files: lib/foo.txt lib/bar.txt",
			"deps:",
			"",
			"task: taskB",
			"files: src/baz.txt",
			"deps:",
			"",
			"task: taskC",
			"files: README.md",
			"deps:",
			""
	};

	vector<string> changedFiles = {
			"lib/foo.txt",
				"README.md"
	};



	vector<string> a = findOrder(taskDefinitionsInput, changedFiles);

	for (string b : a) {
		cout << b << "\n";
	}
}












2










#include <iostream>
#include <string>
#include <map>
#include <set>
#include <vector>
#include <stack>
#include <sstream>

using std::cout;
using std::set;
using std::vector;
using std::string;
using std::map;
using std::stack;


void dfs(map<string, set<string>>& TaskDependencies, string v, map<string, bool>& visited, stack<string>& mystack)
{
	visited[v] = true;
	for (string a : TaskDependencies[v])
		if (visited[a] == false)
			dfs(TaskDependencies, a, visited, mystack);

	mystack.push(v);
}

vector<string> findOrder(vector<string>& entry , vector<string> files) {

	map<string, set<string>>TaskDependencies{};
	map<string, set<string>>FileListForEachTask{};
	map<string, set<string>>FileDependencies{};
	stack<string> order{};
	map<string, bool> visited{};


	for (int i = 0; i < entry.size(); i += 4) {
		string task = entry[i].substr(6);

		std::stringstream depsStream(entry[i + 2]);
		string temp;
		depsStream >> temp;

		set<string> deps;
		while (depsStream >> temp) {
			deps.insert(temp);
			//TaskDependencies[temp].insert(task);
		}

		std::stringstream filesStream(entry[i + 1]);
		filesStream >> temp;


		while (filesStream >> temp) {
			FileDependencies[temp].insert(deps.begin(), deps.end());
			FileDependencies[temp].insert(task);
			FileListForEachTask[task].insert(temp);
		}

		TaskDependencies[task].insert(deps.begin(), deps.end());

	}

	vector<string> ans;

	for (auto [a, b] : TaskDependencies) {
		if (visited[a] == false) {
			dfs(TaskDependencies, a, visited, order);
		}
	}
	while (!order.empty())
	{
		string temp = order.top();
		order.pop();
		for (string a : files) {
			if (FileListForEachTask[temp].count(a) > 0) { 
				ans.push_back(temp);
				break;
			};
		}
	}

	std::reverse(ans.begin(), ans.end());
	return ans;
}



int main() {
	vector<string> input{
		"task: eatDinner",
		"files: kitchen-setup.txt plates.txt",
		"deps: cookRice setupPlates bakePotatoes",
		"",
		"task: cookRice",
		"files: kitchen-setup.txt rice-instructions.txt",
		"deps: setupPlates",
		"",
		"task: bakePotatoes",
		"files: kitchen-setup.txt potato-recipe.txt",
		"deps:",
		"",
		"task: setupPlates",
		"files: plates.txt",
		"deps: bakePotatoes",
		""
	};

	vector<string> a = findOrder(input, { "kitchen-setup.txt" , "plates.txt" });

	for (string b : a) {
		cout << b << "\n";
	}
}







3











#include <iostream>
#include <string>
#include <map>
#include <set>
#include <vector>
#include <stack>
#include <sstream>

using std::cout;
using std::set;
using std::vector;
using std::string;
using std::map;
using std::stack;


bool matchGlob(string glob, string filepath) {
	if (glob.empty() && filepath.empty())return true;
	if (glob.empty())return false;
	if (filepath.empty()) {
		if (glob == "*")return true;
		return false;
	}

	if (glob[0] == '*') {
		string globSliced = glob.substr(1);
		
		if (matchGlob(globSliced, filepath))return true;
		if (filepath[0] == '/')return false;

		string filepathSliced = filepath.substr(1);
		
		if (matchGlob(glob, filepathSliced))return true;
		return false;
	}

	if (glob[0] == filepath[0]) {
		string globSliced = glob.substr(1);
		string filepathSliced = filepath.substr(1);
		return matchGlob(globSliced, filepathSliced);
	}

	return false;

}

vector<string> splitString(string input, string delimiter) {

    size_t start = 0;
    size_t end = input.find(delimiter);
    vector<string> result;
    while (end != std::string::npos)
    {
        result.push_back(input.substr(start, end - start));
        start = end + delimiter.length();
        end = input.find(delimiter, start);
    }

    result.push_back(input.substr(start, end));
    return result;
}
bool match(string globpart, string filepart) {
    if (globpart.empty() && filepart.empty())return true;
    if (globpart.empty())return false;

    if (globpart == "*")return true;

    size_t found = globpart.find("*");
    if (found == std::string::npos) {
        return globpart == filepart;
    }
    else {
        vector<string> globsplit = splitString(globpart, "*");
        for (string a : globsplit) {
            if (a != "") {
                if (filepart.find(a) == std::string::npos)return false;
            }
        }
        return true;

    }
    return false;
}

bool globmatch(string glob, string filepath) {
    if (glob.empty() && filepath.empty())return true;
    if (glob.empty())return false;

    vector<string> globsplit = splitString(glob, "/");
    vector<string> filesplit = splitString(filepath, "/");

    if (globsplit.size() == filesplit.size()) {
        for (int i = 0; i < filesplit.size(); i++) {
            if (match(globsplit[i], filesplit[i]))continue;
            return false;
        }
        return true;
    }
    else {

    }
    return false;
}
void dfs(map<string, set<string>>& TaskDependencies, string v, map<string, bool>& visited, stack<string>& mystack)
{
	visited[v] = true;
	for (string a : TaskDependencies[v])
		if (visited[a] == false)
			dfs(TaskDependencies, a, visited, mystack);

	mystack.push(v);
}

vector<string> findOrder(vector<string>& entry, vector<string> files) {

	map<string, set<string>>TaskDependencies{};
	map<string, set<string>>FileListForEachTask{};
	map<string, set<string>>FileDependencies{};
	stack<string> order{};
	map<string, bool> visited{};
	set<string> globfiles{};
	set<string> Newfiles(files.begin(), files.end());



	for (int i = 0; i < entry.size(); i += 4) {
		string task = entry[i].substr(6);

		std::stringstream depsStream(entry[i + 2]);
		string temp;
		depsStream >> temp;

		set<string> deps;
		while (depsStream >> temp) {
			deps.insert(temp);
			//TaskDependencies[temp].insert(task);
		}

		std::stringstream filesStream(entry[i + 1]);
		filesStream >> temp;


		while (filesStream >> temp) {
			globfiles.insert(temp);
			FileDependencies[temp].insert(deps.begin(), deps.end());
			FileDependencies[temp].insert(task);
			FileListForEachTask[task].insert(temp);
		}

		TaskDependencies[task].insert(deps.begin(), deps.end());

	}

	for (string a : files) {
		for (string b : globfiles) {
			if (globmatch(b, a) ){
				Newfiles.insert(b);
			}
		}
	}

	vector<string> ans;

	for (auto [a, b] : TaskDependencies) {
		if (visited[a] == false) {
			dfs(TaskDependencies, a, visited, order);
		}
	}
	while (!order.empty())
	{
		string temp = order.top();
		order.pop();
		for (string a : Newfiles) {
			if (FileListForEachTask[temp].count(a) > 0) {
				ans.push_back(temp);
				break;
			};	
		}
	}

	std::reverse(ans.begin(), ans.end());
	return ans;
}



int main() {
	vector<string> input{
		"task: distributeImages",
		"files: images/dogs/*.jpg images/*/*.png",
		"deps: compressJpegs compressPngs",
		"",
		"task: compressJpegs",
		"files: images/dogs/*.jpg",
		"deps:",
		"",
		"task: compressPngs",
		"files: images/*/*.png ",
		"deps:",
		"",
	};

	vector<string> a = findOrder(input, { "images/dogs/dalmatians.jpg" , "images/dogs/dalmatians@2.jpg" });

	for (string b : a) {
		cout << b << "\n";
	}
}
